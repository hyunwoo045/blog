{"pageProps":{"postData":{"id":1,"title":"관리자 페이지 - 버전 등록 페이지 개발","date":"2022-12-17","tag":["Spring Boot","Spring JPA","Spring Web","QueryDSL","Vue.js"],"content":"\n- 기간: 2022. 11 ~ 2022. 12, 약 2개월\n- 주요 업무: 코맥스 클라우드 2.0 어드민 페이지 내 리소스 버전 등록 페이지 개발\n- 업무 목적: 실제 유통된 리소스(월패드, 로비폰 등) 내 어플리케이션 버전 등록/업데이트를 위한 페이지 개발\n- 개발 인원: 1인\n- 프로젝트 스펙\n    - Spring Boot\n    - Spring Web MVC\n    - Spring Security\n    - QueryDSL\n    - Vue.js\n\n기존 코맥스 클라우드 2.0 의 관리자 페이지에 OTA(Over The Air) 기능을 추가하는 개발 건의\n여러 요구사항 중 신규 버전 등록을 위한 페이지를 개발하는 업무를 담당하게 되었습니다.\n\n---\n\n## 프로젝트 구조 분석\n\n기본적으로 Spring Web MVC 프레임워크를 사용한 프로젝트로 Apache Tiles 라이브러리를 사용하여\n타일 기반의 레이아웃을 구현한 것으로 보입니다.\n\n```java\n\n@Configuration\npublic class WebMvcConfig implements WebMvcConfigurer {\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        TilesViewResolver viewResolver = new TilesViewResolver();\n        registry.viewResolver(viewResolver);\n    }\n\n    @Bean\n    public TilesConfigurer tilesConfigurer() {\n        TilesConfigurer tilesConfigurer = new TilesConfigurer();\n        tilesConfigurer.setDefinitions(new String[]{\n            \"/WEB-INF/layouts/**/*.tiles.xml\",\n            \"/WEB-INF/views/**/*.tiles.xml\"\n        });\n        tilesConfigurer.setCheckRefresh(true);\n        return tilesConfigurer;\n    }\n}\n```\n\n여러 많은 타일들이 정의되어 있지만 가장 핵심으로 보이는 레이아웃 구성은 아래 코드입니다.\n\n```html\n<!--page.layout.jsp-->\n<html lang=\"ko\">\n<head>\n    <title></title>\n    <!--....-->\n</head>\n<body>\n<div class=\"page-container\">\n    <div class=\"page-content\">\n        <tiles:insertAttribute name=\"leftmenu\"/>\n        <div class=\"content-wrapper\">\n            <div class=\"content\">\n                <tiles:insertAttribute name=\"body\"/>\n                <tiles:insertAttribute name=\"footer\"/>\n            </div>\n        </div>\n    </div>\n</div>\n</body>\n</html>\n```\n\n메인 페이지의 레이아웃을 정의한 모습입니다. 아주 간단해 보이는 HTML 구성이며, body attribute 에 구현한 레이아웃을 삽입할 수 있는 것으로 보입니다. 이 구성에\n맞춰 `/WEB-INF/views/resource/resourcevermng` 라는 버전 관리 페이지의 디렉토리를 생성해주고 `views.tiles.xml` 파일을 생성하여 새로 만들 타일의 설정을 해주었습니다.\n\n```html\n\n<tiles-definitions>\n    <definition name=\"resource/resourcevermng/*\" extends=\"page.layout\">\n        <put-attribute name=\"body\" value=\"/WEB-INF/views/resource/resourcevermng/{1}.jsp\"/>\n    </definition>\n</tiles-definitions>\n```\n\n`resourcemng.jsp` 파일을 생성하여 실제 랜더링 될 페이지의 템플릿을 정의합니다. 페이지를 구성하는 프레임워크는 Vue.js 이므로 Vue.js 의 템플릿 문법에 대한 기억을 더듬어가며 코딩하였습니다.\n세부 코드는 생략합니다.\n\n```html\n\n<div id=\"rootVM\" v-cloak>\n    <!--...-->\n</div>\n\n<script type=\"text/javascript\" src=\"${contextPath}/app/resource/resourcevermng/resourcevermng.js\"/>\n```\n\n최초 프로젝트를 구현한 분의 의도를 정확히 파악할 수는 없으나, 한 파일에 template 과 script 코드가 모두 다 들어가 가독성을 해치는 것을 방지하기 위함이 아니었을까 생각됩니다. `contextPath`\n는 constant 전역 변수로써 `/src/resources/static` 입니다.\n\n`src` attribute 에 정의된 파일을 생성하고 코드를 작성하였습니다. 세부 코드는 생략합니다.\n\n```js\nconst rootVM = new Vue({\n    name: 'RootVM',\n    el: '#rootVM',\n    created() {\n    },\n    data: {},\n    computed: {},\n    methods: {}\n})\n```\n\n페이지 레이 아웃의 구성을 마쳤으니 이제 Resolver 가 `resource/resourcevermng/*` 이름의 타일을 불러올 수 있도록 컨트롤러 메서드를 구현합니다.\n\n```java\n\n@Controller\n@RequestMapping(\"/resource/resourcevermng\")\npublic class ResourceVersionManageController {\n\n    @GetMappging(\"/\")\n    public String index(Model model) {\n        // model.addAttribute()  필요한 데이터를 보내줍니다.\n        return \"/resource/resourcevermng/resourcevermng\";\n    }\n}\n```\n\n---\n\n### QueryDSL\n\n요구되는 페이지 기능 상 쿼리가 필요하기 때문에 그에 관련 된 구조 또한 파악할 필요가 있었습니다. Spring 의 ORM 스펙 중 하나인 `QueryDSL`\n을 사용하고 있습니다. 부분 필터링 기능을 구현해야 하는 어드민 페이지이었기 때문에 `QueryDSL` 채택은 아주 합리적이라고 생각합니다.\n\n실제 구현한 코드를 예시로 들며 설명해보겠습니다.\n\n![ota_resource_vermng](/images/ota/1.png)\n\n화면에 보이듯 총 7개의 검색 필드가 존재하는데 7개의 필드를 모두 다 채워 검색해야 한다면 사용성이 매우 떨어지니 당연히 일부 필드만 채워 검색하더라도 필터가 적용된 검색 결과를 보여주어야 합니다. 이를 JPA 의\n일반적인 쿼리 메서드로 구현한다고 하면 이 한 기능을 위해 수도 없이 많은 메서드를 정의해야 했을 것입니다.\n\n```java\n// 실제 코드가 아닌 예시입니다.\n\n@Repository\npublic interface ResourceVersionRepository extends JpaRepository<ResourceVersion, Long> {\n    List<ResourceVersion> findByModelName(String modelName);\n\n    List<ResourceVersion> findByModelNameAndModelType(String modelName, String modelType);\n\n    List<ResourceVersion> findByModelNameAndModelTypeAndVersion(String modelName, String modelType, String version);\n    // .....수십개의 method T_T\n}\n```\n\n이런 상황에서는 동적 쿼리가 작성 가능한 방법을 찾아야 하는데 `QueryDSL` 은 이를 해결해줄 JPQL 빌더입니다.\n\n기존 설정이 이미 완료되어 있고 컴파일 시 `/target/generated-sources/java/{package}/entity` 아래 QModel 들이 생성되는 것을 확인하였으니 추가된 테이블을 정의합니다. 실제\n코드와는 다른 예시입니다.\n\n```java\n\n@Entity\n@Getter\n@Setter\n@Table(name = \"tbl_resource_version\")\npublic class ResourceVersion {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(columnDefinition = \"int\")\n    private Long seqno;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"modelSeqno\")\n    private ResourceModel model;\n\n    private String version;\n\n    private String registerAdmin;\n\n    private String updateAdmin;\n\n    @Column(columnDefinition = \"int\")\n    private Long registerTs;\n\n    @Column(columnDefinition = \"int\")\n    private Long updateTs;\n}\n```\n\n이 후 다시 컴파일하면 `QResourceVersion` 이라는 새로운 QModel 이 생성된 것을 볼 수 있습니다.\n\n```java\n\n@Generated(\"com.querydsl.codegen.EntitySerializer\")\npublic class QResourceVersion extends EntityPathBase<ResourceVersion> {\n    //...\n}\n```\n\n동적 쿼리를 작성합니다. 역시 실제 코드와 다른 예시입니다.\n\n```java\n\n@Repository\npublic class ResourceVersionRepository {\n\n    @Autowired\n    private JPAQueryFactory queryFactory;\n\n    /**\n     * SearchMap 은 ServletRequest 를 HashMap<String, Object> 의 형태로 변환시킨 객체입니다.\n     */\n    public QueryResults<Tuple> queryVersionList(SearchMap map, Sort sort) {\n        BooleanBuilder filter = new BooleanBuilder();\n        QResourceVersion v = new QResourceVersion(\"v\");\n        QResourceModel m = new QResourceModel(\"m\");\n\n        if (map != null) {\n            String modelName = (String) map.get(\"modelName\");\n            String modelType = (String) map.get(\"modelType\");\n            String version = (String) map.get(\"version\");\n\n            // 동적 쿼리 조건문 추가 \n            if (modelName != null) filter.and(m.modelName.eq(modelName));\n            if (modelType != null) filter.and(m.modelType.eq(modelType));\n            if (version != null) filter.and(v.version.eq(version));\n\n            // 쿼리 실행\n            JPAQuery<Tuple> query = queryFactory\n                .select(m.modelName, m.modelType, v.version)\n                .from(v)\n                .leftJoin(v.model(), m)\n                .where(filter);\n\n            return query.fetResults();\n        } else {\n            // 필터 없이 전체 검색...\n        }\n    }\n}\n```\n\n이 후 `QueryResults<Tuple>` 형태의 결과값은 DTO 형태로 변환하여 페이지에 전달하도록 구현하였습니다.\n\n---\n\n## AWS S3 에 바이너리 업로드\n\nJavaScript 용 AWS SDK 가\n있습니다. [공식 문서](https://docs.aws.amazon.com/ko_kr/sdk-for-javascript/v2/developer-guide/welcome.html) 를 참고하여 AWS S3 에 업로드가\n가능하도록 구현하였습니다.\n\n앞단은 엄밀히 따지자면 Node.js 프로젝트가 아니므로 브라우저 스크립트로 SDK 를 포함시켜야 했습니다.\n\n```html\n<!--resourcevermng.jsp-->\n\n<!-- ..... -->\n<script src=\"https://sdk.amazonaws.com/js/aws-sdk-2.1254.0.min.js></script>\n```\n\nAWS 접근 권한을 부여하기\n위해 [공식 문서](https://docs.aws.amazon.com/ko_kr/sdk-for-javascript/v2/developer-guide/getting-started-browser.html) 의 1단계,\n2단계 내용을 참고하여 CognitoIdentity Pool 을 생성하고 정책을 부여하였습니다. 이 후 권한을 가진 Pool ID 를 받을 수 있습니다. 이를 바탕으로 포함시킨 SDK 를 확장합니다.\n\n마지막으로 역시 공식 문서를 참조하여 페이지에서 전달받은 바이너리 파일을 AWS S3에 업로드 하였습니다.\n\n```js\nasync function uploadFileToS3() {\n    // ...v-model > closure. file 에 관한 정보를 가져옴\n    \n    var credentials = new AWS.CognitoIdentityCredentials({\n        IdentityPoolId: 'ap-northeast-2:key...'\n    });\n    AWS.config.update({\n        region: 'ap-northeast-2',\n        credentials,\n    });\n    let s3 = new AWS.s3({\n        computeChecksums: true\n    });\n    let body = {\n        Bucket: 'bucket-name',\n        Body: file,\n        Key: fileName\n    }\n    const putResult = await s3.putObject(body).promise();\n}\n\n```\n\n"}},"__N_SSG":true}