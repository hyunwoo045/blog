---
title: "관리자 페이지 - 운영 관제 시스템 개발"
excerpt: "Cloudv1 장애 대응 시스템 개발"

header:
overlay_image: https://images.unsplash.com/photo-1501785888041-af3ef285b470?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80
overlay_filter: 0.5

tags:
- Node.js
- React
- Redux
- Express
- ElasticSearch
- Redis
- MariaDB

toc: true
toc_label: "table of content"
toc_icon: "bars"
toc_sticky: true
---

- 기간
  - 초기 백엔드 프로젝트 구성 (2022년 8월, 2주)
  - 트러블 슈팅, 코드 리팩토링 (2023년 2월 ~ 3월, 3주)
- 구성 인원: 1인
- 주요 업무
  - 백엔드 초기 구조 구현
  - 트러블 슈팅
  - 프론트엔드 코드 리팩토링
  - Gitlab pipeline 코드 및 Dockerfile 코드 수정
- 결과: 버그 픽스 후 서비스 정상화 완료.
- 기술 스택
  - 프론트엔드
    - React
    - Redux
  - 백엔드
    - Express
    - MariaDB
    - ElasticSearch
    - Redis
  - Gitlab pipeline
  - Docker

서비스 장애 발생 시 장애 내용이 파악되지 않고 전 부서로 메일 및 JIRA 를 통해 무분별하게 전달되어 
업무 효율을 저하시키는 구조를 개선하고자 서비스 최전단에 어드민 페이지 형태의 관제 시스템을 배치하는 목적의 프로젝트입니다.
외주 담당 프로젝트이지만 내부 사정으로 일부 업무를 지원하였습니다.

## 백엔드 어플리케이션 초기 구조 구현

백엔드 어플리케이션 기술 스택은 Javascript, Express 런타임을 채택합니다. 구현 자유도가 매우 높은 것이 장점이나
코드를 아주 잘 짜지 않는다면 같은 코드여도 항상 같은 동작을 확신할 수 없다는 점, 타입 안정성 또한 확신할 수 없다는 점 등
스택 자체가 매우 불안정하다고 느끼기 때문에 개인적으로 싫어합니다만, 외주 인력이 Javascript 외 기술을 사용할 수 없는 점 때문에
해당 스택을 채택합니다.

간단하게 디렉토리 구조를 정하고 서버 이니시에이팅 코드와 요구사항의 일부 코드를 구현한 후 인수인계 하는 것이 목표입니다.

### 디렉토리 구조

`/src` 디렉토리 내 아래와 같은 패키지들로 구성합니다.

- `/api`: 아래 `/user`, `/resource` 등의 하위 폴더 내 각 controller, service, repository 를 포함하여 컨트롤러 메서드 전반에 필요한 기능을 구현
- `/dto`: HTTP 통신에 필요한 Data 전송 객체의 구현. 대표적으로 AWS OpenSearch 로의 쿼리 Body 가 정의됨.
- `/lib`: logger, database connection pool 등의 라이브러리 객체 구현
- `/middleware`: request handler (AOP 객체), error interceptor 등의 미들웨어 함수 구현

기타 `/common`, `/util`, `/env` 과 같은 디렉토리들을 구성하였습니다.

### App 확장

`Controller` 객체 의존성을 추가하고 `Middleware` 함수 의존성을 추가하여 Express 앱을 확장합니다.

컨트롤러 객체 코드 예시입니다.

```js
export default class UserController {
    path = "/user";

    router = Router();

    constructor() {
        this.initializeRoutes();
    }

    initializeRoutes = () => {
        const router = Router();

        router.get('/', this.getUser);

        this.router.use(this.path, router);
    }

    getUser = (req, res) => {
        const {userId} = req.params;
        console.log('유저를 검색합니다~');
    }
}
```

위와 같은 컨트롤러를 앱이 생성될 때 배열 형태로 주입하여 의존성을 생성합니다.

```js
import express, {Router} from 'express';

class App {
    app;

    // 앱 생성 시 controller 의존성을 주입받음
    constructor(controllers) {
        this.app = express();

        this.initializeControllers(controllers);
    }

    listen() {
        const port = process.env.PORT || 3000;
        this.app.listen(port, () => {
            logger.info(`App listening on the port ${port}`);
        });
    }

    initializeControllers(controllers) {
        const router = Router();
        controllers.forEach(controller => {
            router.use(controller.router);
        });

        this.app.use('/api', router);
    }
}
```

서비스 중 Exception 이 발생하더라도 원하는 형태의 response 가 내려가도록 인터셉터 개념의 미들웨어를 추가해 줄 필요가 있습니다.

```js
export const errorMiddleware = (err, req, res, next) => {
    const status = err.status || 500;
    const message = err.message;

    res.status(status).send({
        success: false,
        error: {
            status,
            message
        }
    });
    
    next();
}
```

이 미들웨어 함수 또한 앱이 생성될 때 확장되도록 구성합니다.

```js
import express, {Router} from 'express';
import {errorMiddleware} from "./middleware/error.middleware.js";

class App {
    app;

    constructor(controllers) {
        this.app = express();

        this.initializeControllers(controllers);
        this.initializeErrorHandling();
    }

    listen() {
        const port = process.env.PORT || 3000;
        this.app.listen(port, () => {
            logger.info(`App listening on the port ${port}`);
        });
    }

    initializeControllers(controllers) {
        const router = Router();
        controllers.forEach(controller => {
            router.use(controller.router);
        });

        this.app.use('/api', router);
    }

    initializeErrorHandling() {
        this.app.use(errorMiddleware);
    }
}
```

### 데이터베이스 연결성 검사

앱이 구동되기 전 데이터베이스 연결성을 우선 검사하여 서비스가 정상적으로 동작할 수 있는 환경을 검증합니다.

MariaDB 는 커넥션 풀을 생성하고 필요한 경우에만 커넥션을 생성하는 방식으로 구현합니다. 풀을 생성하고 정상적으로 커넥션을
얻을 수 있는 지 확인하여 연결성을 검증합니다.

```js
import mariadb from 'mariadb';

const mariaConfig = {
    // db 정보....
}

export const pool = mariadb.createPool(mariaConfig);

export async function mariaCheckConnection() {
  let conn;
  try {
    conn = await pool.getConnection((err, conn) => {
      if (err) throw err;
    })
  } catch (err) {
    throw err;
  } finally {
    if (conn) conn.release();
  }
}
```

redis 데이터베이스로의 연결성을 검증합니다. redis 의 경우 cluster 로 구성되어 있기 때문에 `rs-wrapper` 패키지를 이용하여
연결합니다.

```js
import redisConnector from 'rs-wrapper';

const redisConfig = {
    // redis 정보...
}

redisConnector.config(redisConfig);

export {redisConnector};

export async function redisCheckConnection() {
  let sample = 123;
  try {
    await redisConnector.set('init-key', sample, (err) => {
      if (err) throw err;
    });

    await redisConnector.get('init-key', (err, result) => {
      if (err) throw err;
      else {
        if (sample !== result) throw Error('Something wrong with redis');
      }
    })
  } catch (err) {
    throw err;
  }
}
```

어플리케이션이 시작될 때 모두 커넥션을 검사 후 정상이어야 구동이 가능하도록 합니다.

```js
import App from "./app.js";
import {mariaCheckConnection, redisCheckConnection} from '../lib/database.js';
import UserController from "./api/user/user.controller.js";

async function startServer() {
    try {
        await mariaCheckConnection();
        await redisCheckConnection();
    } catch (error) {
        console.error(error);
        process.exit();
    }
    
    const app = new App([
        new UserController(),
    ]);

    app.listen();
}

startServer().then(() => console.log("System Initiated"));
```

## OpenSearch (ElasticSearch) 쿼리 메서드

자사 클라우드 인프라 내 OpenSearch 에 적재되는 로그는 일정한 패턴을 가집니다. 
이를 아래와 같이 표현하여 반복 코드를 줄일 수 있습니다.

```js
export function getBasicTrxSearchQuery(url, method, startDate, endDate) {
    return {
        "sort": {
            "@timestamp": "desc"
        },
        "size": 100,
        "query": {
            "bool": {
                "must": [
                    {"match_phrase": {"request.uri": url}},
                    {"match_phrase": {"request.method": method}}
                ],
                "filter": [
                    {"range": {"@timestamp": {"gte": startDate, "lte": endDate}}}
                ]
            }
        }
    }
}
```

이에 요구 사항에 맞춰 필요한 쿼리는 변형하여 request body 를 구성할 수 있겠습니다. 아래는 uri 에 query parameter 로
`${userId}` 가 포함되어 있는 로그를 검색하는 예시 코드입니다.

```js
import {getBasicTrxSearchQuery} from '../dto/log.request.dto.js';

export class Repository {
    findLogsByUserId = async (uri, index, method, userId, startDate, endDate) => {
        const body = getBasicTrxSearchQuery(uri, method, startDate, endDate);
        body.query.bool.must.push({
            "match": {
                "request.uri": userId
            }
        });
        return await this.sendQueryToOpenSearch(index, body);
    }
    
    private sendQueryToOpenSearch = async (index, body) => {
        return await axios.post(`${openSearchHost}/${index}/_search`, body)
            .then(res => {
                return res.data.hits.hits;
            })
            .catch(err => {
                throw new Error(err);
            });
    }
}
```

이와 같이 초기 프로젝트를 구현하고 인수인계를 마쳤습니다.

---

## 트러블 슈팅

히스토리를 전달받지 못해 알 수 없으나 특정 시점에서 서비스에 버그가 발생하였고,
이 또한 사정을 알 수 없으나 업체 측에서 버그를 해결하지 못한 채로 서비스가 긴 시간 방치되었습니다.
초기 프로젝트룰 구성하였다는 이유로 트러블 슈팅 업무를 지원하게 됩니다.

관리자 페이지에서 동작하지 않는 기능은 핵심 서비스였던 로그 조회에 관련된 전체 서비스였습니다.
`500 Internal Server Error` 가 내려오거나 실제 로그가 있음에도 불구하고 조회되지 않는 문제였습니다.

파악한 원인은 아래와 같습니다.

1. 로그를 적재하는 방식이 변경됨
    - 요청에 각 request, response, trx 이라는 세 개의 로그 타입을 따로 저장하던 방식에서 trx 만 저장하고 request, response 의 내용을 모두 통합함.
    - 기존 로그 검색 방식은 trx 로그 타입을 제외하고 request, response 만을 검색한 후 `trxId` 를 추출하여 trx 로그를 검색하여 필요한 정보를 필터링 하는 방식이어 이에 1번 내용과 충돌. 아무 로그도 검색되어 나오지 않음.
2. 검색되어진 로그들에 `filter` 메서드를 적용하는 과정에서 `TypeError` 발생. `undefined` 를 고려하지 않음.

1번 문제는 내부 정책을 변경한 후에 커뮤니케이션이 정상적으로 이루어지지 않은 것으로 보입니다.
초기 프로젝트 구성 당시 작성한 `BasicTrxSearchQuery` 의 body 를 수정합니다.

2번 문제는 원인이 아주 명확한 코드 상의 오류이므로 이 또한 수정합니다. <s>(타입 안정성을 보장하지 않는 Javascript 싫다!)</s>

---

## 코드 리팩토링

버그 픽스 후 페이지를 테스트 해 보고 프론트엔드 코드를 확인해보는 과정에서 많은 문제들을 확인하였습니다.
당시 나열한 문제들은 아래와 같습니다.

1. `Header`, `Side NavigationBar` 랜더링 코드가 11개의 파일에서 반복 코딩됨.
2. `Side NavigationBar` 내 메뉴를 리스트 업하고 navigate 기능을 정의한 코드가 11개의 파일에서 반복 코딩됨.
3. 로그 조회 결과를 리스트업 하는 테이블의 column 정의가 5개의 파일에서 반복 코딩됨.
4. 로그인 한 유저만 페이지를 열람할 수 있어야 한다는 정책에 따라 로그인 여부를 확인하는 로직이 11개의 파일에서 반복 코딩됨.
5. 특정 권한에서만 수행할 수 있는 기능이 존재하는 3개의 페이지에서 권한을 확인하는 로직이 반복 코딩됨.
6. `useState` hook 사용 중 object 와 같은 mutable type 의 state 를 변경하는 과정에서 오류를 일으킬 수 있는 코드가 다수 존재함.
7. `axios` 를 사용하는 12개의 페이지에서 패키지를 반복 import 해서 사용하여 설정 확장이 요구될 시 반복 하드 코딩해야 함.
8. 로그인 시 부여받는 권한을 별도의 암호화 과정 없이 cookie 로 전달받음.

악의가 느껴질 정도의 반복 코드 문제가 대부분입니다. 이는 이 후 유지보수, 확장, 운영을 하는 과정에서 반드시
문제를 일으킬 코드이기 떄문에 이를 책임자에게 보고하고 별도의 리팩토링 일정을 받았습니다. 

React 프로젝트의 디렉토리 구조를 개선한 것을 간단히 소개하겠습니다.

- `/api`
- `/components`
- `/hocs`
- `/pages`
- `/routes`
- `/store`
- 기타 `/constant`, `/common`, `/utils`

---

### `/api`

`axios` 패키지를 이용한 API 호출 함수들을 정의해 둔 디렉토리 입니다. `axios` 설정을 하여 export 한 후 하위 function 들이 이를
가져다가 사용하는 방식으로 구현하였습니다.

```js
// api.js

import axios from "axios";

export default axios.create({
    baseURL: process.env.REACT_APP_API_URL,
    withCredentials: true,
});
```

```js
// user/index.js

import api from '../api';
import {handleResponseError} from "../../common";

const path = "/api/users"

export const getUserInfo = async(userId) => {
    try {
        const response = await api.get(path, {params: {userId}});
        return response.data.result;
    } catch (error) {
        // axios 는 2xx response 가 오지 않으면 error 를 발생시킵니다.
        handleResponseError(error);
        return null;
    }
}
```

### `/component`

페이지의 주요 컴포넌트 구성을 정의한 내용을 포함하여, `Header`, `Sidebar`, `SearchBar` 등 재사용성이 높은 하위 컴포넌트들을
구현하였습니다.

### `/hocs`

주요 페이지 컴포넌트들 중 반복적으로 사용되는 로직이 있습니다. 기본적으로 로그인 후 계정 생성 시 부여받은 권한에 따라 사용할 수 있는 기능이
제한되는 시스템이기 때문에 페이지마다 현재 로그인 되어 있는 사용자의 권한을 체크할 필요가 있었습니다. 이는 매우 반복적이기 때문에 이를
효율적으로 재사용하기 위한 방법으로 고차 컴포넌트(HOC, Higher Order Component) 개념을 알게 되고 이를 활용하게 되었습니다.

`/hocs` 디렉토리는 이러한 컴포넌트들을 모아놓은 디렉토리입니다.

```js
import {useDispatch, useSelector} from "react-redux";
import {selectAdmin, setUserInfo} from "../store/adminSlice";
import {useEffect} from "react";
import {tokenAdmin} from "../api/admin";
import {message} from "antd";
import {useNavigate} from "react-router-dom";

export const withCredentials = (WrappedComponent) => {
    return function WithCredentials(props) {
        const admin = useSelector(selectAdmin);
        const dispatch = useDispatch();
        const navigate = useNavigate();
        
        useEffect(() => {
            // localStorage 내 토큰을 API 서버로부터 검증받고, 토큰 내 유저 정보를 전달받아 store 에 저장.
        });
        
        return (
            <WrappedComponent {...props}/>
        )
    }
}
```

### `/pages`

`router` 로 정의되어 있는 타겟 페이지 컴포넌트들을 모아놓은 디렉토리입니다.

### `/routes`

라우터 정의입니다.

```js
import React from 'react';
import {BrowserRouter as Router, Route, Routes} from 'react-router-dom';
import * as Pages from "../pages";

const routes = (
    <Router>
        <Routes>
            <Route path={"/login"} element={<Pages.Login/>}/>
            <Route path={"/"} element={<Pages.Main/>}>
                <Route path={"/"} element={<Pages.Home/>}/>
                <Route path={"/admin"} element={<Pages.Admin/>}/>
            </Route>
        </Routes>
    </Router>
);

export default routes;
```

로그인 페이지는 Header, Sidebar 가 없는 페이지 구성이므로 별도로 페이지를 구성하고, 그 외 페이지들은 이 둘을 모두 포함하므로
아래와 같이 페이지에 `Outlet` 컴포넌트를 정의함으로써 자식 라우터가 호출될 시 `Outlet` 컴포넌트의 위치에 랜더링 되도록 구현하였습니다.

아래와 같이 구현함으로써 페이지를 이동할 때 Header 와 Sidebar 가 모두 같이 렌더링되는..
React 라는 반응형 프레임워크를 사용하는 가치를 잃어버리지 않게 할 수 있습니다.

```js
// Main.js
import React from 'react';
import {
    Header as HeaderComponent,
    Sidebar as SidebarComponent
} from '../../components';
import {Outlet} from "react-router-dom";

const Main = () => {
    return (
        <>
            <HeaderComponent/>
            <div className={"content"}>
                <SidebarComponent/>
                <Outlet/>
            </div>
        </>
    )
}

export default Main;
```

### `/store`

`/hocs` 부분에서도 서술했듯 로그인 되어 있는 유저 정보의 경우 거의 대부분의 페이지에서 사용되는 정보이므로 이를 전역 변수처럼 원할 때
사용 가능하도록 할 필요가 있었습니다. 하지만 전역 변수의 사용은 가급적 지양해야 하므로 안전하게 전역 변수를 관리할 수 있는 `Store` 기능을
사용하였습니다. 해당 디렉토리는 React 의 `redux` 라이브러리의 설정 및 관리할 state 들을 정의한 디렉토리입니다.

이와 같이 구조를 설계하고 최소 단위의 컴포넌트를 정의하도록 신경써 반복 코드를 최대한 줄일 수 있습니다.

```js
// store.js
import adminReducer from './adminSlice';
import {configureStore} from "@reduxjs/toolkit";

const store = configureStore({
    reducer: {
        admin: adminReducer
    }
});

export {store};
```

```js
import {createSlice} from "@reduxjs/toolkit";

export const adminSlice = createSlice({
    name: 'admin',
    initialState: {
        admin: {
            status: false,
            userId: "",
            role: "",
            token: "",
            exp: 0
        }
    },
    reducers: {
        setUserInfo: (state, action) => {
            state.admin = {...action.payload}
        },
    }
})

export const {setUserInfo} = adminSlice.actions;

export const selectAdmin = state => state.admin.admin;

export default adminSlice.reducer;
```

---

23년 3월 6일부로 외주 업체 인력이 충원됨에 따라 프로젝트를 인수 인계 하였습니다.