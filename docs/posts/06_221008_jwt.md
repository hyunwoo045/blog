---
title: "인증 서버 클라이언트 검증 로직 변경"
excerpt: "세션 인증 방식에서 토큰 인증 방식으로 변경"

header:
overlay_image: https://images.unsplash.com/photo-1501785888041-af3ef285b470?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80
overlay_filter: 0.5

tags:
- Spring Boot

toc: true
toc_label: "table of content"
toc_icon: "bars"
toc_sticky: true
---

- 기간: 2022년 10월, 약 3주
- 구성 인원: 1인
- 주요 업무
    - 검증 로직의 개선 구조 설계 및 구현
- 결과: 개발 완료 후 개발계 배포 완료. 2023년 3월 기준 관계 부서 업데이트 대기 중.
- 개선점: Redis 리소스를 제거하여 전체 서버 비용 중 7~10% 절감 예상.
- 기술 스택
    - Spring Boot (Java)
    - Json Web Token

서버 비용을 절감하라는 회사 지침에 따라 인프라 리소스 경량화를 진행하였습니다. 대상자 중 하나는 Redis 입니다. Redis 는 서비스 내에서 세션 기능만을 수행하고 있지만 전체 서버 비용 중 7~10% 를
차지하고 있습니다. 클라이언트 인증 절차에 문제가 있는 것은 아니었지만 오롯이 비용 절감을 목적으로 Redis 를 제거하고 세션 기반의 인증 로직을 변경합니다.

---

## Legacy. 세션 기반 인증 방식

기존의 인증 방식은 매우 간단합니다.

![legacy_session](/images/jwt/1.png)

전형적인 세션 기반 인증 시스템입니다. 로직 상으로는 문제될 것이 없어 보입니다만, 서버에 들어가는 비용을 제한한다면 얘기가 조금 달라집니다. 서비스가 지속되고 서비스를 이용하는 사용자의 수가 늘어난다면 Redis
에 저장되는 데이터의 절대적인 양 또한 마찬가지로 늘어날 것이고, 그에 따라 투입되어야 할 비용이 더 커질 것입니다.

---

## 토큰 기반 인증 방식 (Json Web Token)

Signature 를 포함한 토큰을 발행하여 클라이언트에 전달하여 저장하게 하고 이 후 요청 시 Header: Authorization 에 토큰을 포함하도록 하는 방식입니다. 서버에서는 토큰에 포함된
Signature 를 복호화하여 유효성을 검증하므로 토큰을 저장소에 저장할 필요가 없어 Stateless 한 구조를 가지게 됩니다. 현재 목적에 매우 적합한 방식이므로 이를 채택합니다.

추가로 토큰의 주인, 요청을 보낸 클라이언트의 정보가 대부분의 비즈니스 로직에 필요하므로 토큰을 생성할 때에 대상자의 정보를 포함할 필요가 있습니다. 이러한 요구를 충분히 만족시키는
기법인 `JSON Web Token` [RFC7519](https://datatracker.ietf.org/doc/html/rfc7519) 이라는 기법이 있으므로 이를 채용하였습니다.

```
Signature = HmacSHA256((B64(Header).B64(Payload)), secret)
Token = B64(Header).B64(Payload).B64(Signature)
```

일부 [RFC7519](https://datatracker.ietf.org/doc/html/rfc7519) 서술한 내용이 다를 수는 있으나 표준은 아니기 때문에 만들기 나름인 것 같습니다.
아주 간단한 기법이므로 직접 구현합니다. 아래는 실제 코드를 기반으로 일부 내용을 생략한 예시 코드입니다.

```java
@Component
@RequiredArgsConstructor
public class CommaxToken {

    private final ObjectMapper mapper;

    @Value("${...}")
    private int expireTime;

    @Value("${...}")
    private int reExpireTime;

    @Value("${...}")
    private String tokenSecret;

    public String generateToken(NumberType numberType, String number, String clientId, TokenType tokenType) {
        int eTime = (tokenType == TokenType.ACCESS_TOKEN) ? expireTime : reExpireTime;
        String result = "";

        ObjectNode header = mapper.createObjectNode();
        header.put("alg", "HS256");
        header.put("typ", "JWT");
        result += this.base64url_encode(header.toString().getBytes(StandardCharsets.UTF_8));

        int now = (int) (new Date().getTime() / 1000);
        ObjectNode payload = mapper.createObjectNode();
        payload.put("iat", now);
        payload.put("exp", now + eTime);
        payload.put("typ", numberType.value());
        payload.put("no", number);
        payload.put("cli", clientId);
        result += "." + this.base64url_encode(payload.toString().getBytes(StandardCharsets.UTF_8));

        String sig = this.Hmac(tokenSecret, result, "HmacSHA256");
        return result + "." + new String(sig.getBytes(StandardCharsets.UTF_8));
    }

    public TokenVO parse(String tokenStr) {
        String[] parts = tokenStr.split("\\.");
        if (parts.length != 3) {
            if (tokenStr.equals("tmpkey")) return null;
            else throw new CmxBaseException(ResultCode.UNAUTHORIZED, "Not a valid JWT Token (invalid structure");
        } else {
            try {
                ObjectNode header = mapper.readValue(new String(Base64.getDecoder().decode(parts[0].getBytes(StandardCharsets.UTF_8))), new TypeReference<ObjectNode>() {
                });

                String tmp = new String(Base64.getDecoder().decode(parts[1]));
                ObjectNode payload = mapper.readValue(tmp, new TypeReference<ObjectNode>() {
                });
                TokenVO token = new TokenVO();
                token.setBLegacy(false);
                token.setNumberType(payload.get("typ").asText());
                token.setNumber(payload.get("no").asText());
                token.setClientId(payload.get("cli").asText());
                token.setIssuedAt(payload.get("iat").asInt());
                token.setExpireAt(payload.get("exp").asInt());

                String calcSig = this.calcSignature(parts[0], parts[1]);
                token.setBSignatureValid(calcSig.equals(parts[2]));

                int now = (int) (new Date().getTime() / 1000);
                token.setBExpired(now > token.getExpireAt());

                return token;
            } catch (JsonProcessingException e) {
                throw new CmxBaseException(ResultCode.INTERNAL_SERVER_ERROR, "Json parse error");
            }
        }
    }

    public void validate(TokenVO token, NumberType type) {
        if (!token.isBSignatureValid()) throw new TokenTypeInvalidExceptionCmx("Token signature validation failed");
        if (token.isBExpired()) throw new TokenTypeInvalidExceptionCmx("Expired token");
    }

    public String calcSignature(String encHeader, String encPayload) {
        return this.Hmac(tokenSecret, encHeader + "." + encPayload, "HmacSHA256");
    }

    private String base64url_encode(byte[] str) {
        String b64 = Base64.getEncoder().encodeToString(str);
        b64 = b64.replace("+", "-");
        b64 = b64.replace("/", "_");
        return StringUtil.rtrim(b64, "=");
    }

    private String Hmac(String key, String message, String algorithm) {
        try {
            Mac hashing = Mac.getInstance(algorithm);
            hashing.init(new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), algorithm));
            byte[] hash = hashing.doFinal(message.getBytes());
            return base64url_encode(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new CmxBaseException(ResultCode.INTERNAL_SERVER_ERROR, "Internal Server Error: cannot generate token with algorithm: " + algorithm);
        } catch (InvalidKeyException e) {
            throw new CmxBaseException(ResultCode.INTERNAL_SERVER_ERROR, "Invalid Key");
        }
    }
}
```

토큰을 생성하고 검증하는 객체를 생성하여 Bean 으로 등록해줍니다. 
이 후 서비스, Resolver 등에서 해당 Bean 을 주입하여 사용하도록 합니다.

---

## 2023년 3월 기준 현황

기존 방식에서 사용하던 세션을 복호화하여 사용하는 관계 부서가 있어 해당 내용을 전파하고 업데이트를 기다리고 있습니다.
상용 서비스에 배포가 완료되더라도 6개월 (기존 세션 토큰 만료 기간) 동안 병행하는 구조를 유지해야 합니다. 즉,
현재 검증 로직 신규 로직으로 검증을 시도해보고 검증에 실패할 경우 기존 검증 로직으로 한번 더 검증을 시도합니다.
병행 구조를 유지하며 Redis 내 데이터가 모두 만료되어 자동 삭제되기를 기다릴 계획입니다.