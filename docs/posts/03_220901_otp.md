---
title: "연동 OTP 기능 개발"
excerpt: "시간 기반 일회용 패스워드 기능 구현"

header:
overlay_image: https://images.unsplash.com/photo-1501785888041-af3ef285b470?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80
overlay_filter: 0.5

tags:
- Spring Boot

toc: true
toc_label: "table of content"
toc_icon: "bars"
toc_sticky: true
---

- 기간: 2022년 9월, 1주
- 구성 인원: 1인
- 주요 업무
    - 6자리 OTP 코드 생성 메서드 구현
    - 관련 RDB Table 설계 및 생성
- 결과: 2022년 9월 개발 및 배포 완료
- 기술 스택
    - Spring Boot (Java)

솔루션 파트너 사의 요청으로 QR 코드 내 OTP 기능을 추가하는 요구 사항입니다. QR 코드 재사용을 방지하기 위한 기능입니다.

---

## 구현 예시

OTP 를 생성하는 객체를 구현합니다. 아래는 예시 코드이며 실제와는 일부 다른 부분이 있습니다.

참고 자료: [RFC6238](https://www.rfc-editor.org/rfc/rfc6238)

```java
@Component
public class TOTP {

    @Value("{v2auth.totp.secret}")
    private String secret;

    private byte[] hmac_sha(String algorithm, String key, byte[] message) {
        try {
            Mac hashing = Mac.getInstance(algorithm);
            hashing.init(new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), algorithm));
            return hashing.doFinal(message);
        } catch (NoSuchAlgorithmException e) {
            throw new CmxBaseException(ResultCode.INTERNAL_SERVER_ERROR, "Internal Server Error: cannot generate token with algorithm: " + algorithm);
        } catch (InvalidKeyException e) {
            throw new CmxBaseException(ResultCode.INTERNAL_SERVER_ERROR, "Invalid Key");
        }
    }

    private byte[] hexStr2Bytes(String hex) {
        byte[] bArray = new BigInteger("10" + hex, 16).toByteArray();
        byte[] ret = new byte[bArray.length - 1];
        System.arraycopy(bArray, 1, ret, 0, ret.length);
        return ret;
    }

    public String generateTOTP(int returnDigits, String algorithm) {
        long time = System.currentTimeMillis();
        String steps = Long.toHexString(time).toUpperCase();
        StringBuilder timeBuilder = new StringBuilder(steps);
        while (timeBuilder.length() < 16) {
            timeBuilder.insert(0, "0");
        }
        String timeStr = timeBuilder.toString();

        byte[] msg = hexStr2Bytes(timeStr);
        byte[] hash = hmac_sha(algorithm, secret, msg);

        int offset = hash[hash.length - 1] & 0xf;
        int binary =
            ((hash[offset] & 0x7f) << 24) |
                ((hash[offset + 1] & 0xff) << 16) |
                ((hash[offset + 2] & 0xff) << 8) |
                (hash[offset + 3] & 0xff);

        int otp = binary % (int) Math.pow(10, returnDigits);
        StringBuilder result = new StringBuilder(Integer.toString(otp));
        while (result.length() < returnDigits) {
            result.insert(0, "0");
        }
        return result.toString();
    }
}
```

Service 레벨에서 리소스의 유효 OTP 를 저장하는 메서드, 검증 메서드, 삭제 메서드를 구현합니다.

```java
public class OauthService {

    @Autowired
    private TOTP totp;

    @Value("{...}")
    private Long otpDuration;

    @Override
    public String createOtp(Resource resource) {
        Otp otp = new Otp();
        String code = totp.generateTOTP(6, "alg");

        otp.setResource(resource);
        otp.setCode(code);
        otp.setCreateAt(System.currentTimeMillis());
        otp.setExpireAt(System.currentTimeMillis() + otpDuration);
        otp.setIsValid("Y");
        otpRepository.save(otp);

        return code;
    }

    @Override
    public Otp validateOtpCode(Resource resource, String code) {
        List<Otp> results = otpRepository.findByResourceAndCodeOrderByCreateAtDesc(resource, code);

        if (results.size() == 0) {
            throw new CmxBaseException(ResultCode.AUTH_INVALID_OTP, "invalid OTP code");
        } else {
            Otp otpCol = results.get(0);
            if (otpCol.getExpireAt() < System.currentTimeMillis()) {
                throw new CmxBaseException(ResultCode.AUTH_EXPIRED_OTP, "expired OTP code");
            } else {
                if (otpCol.getIsValid().equals("N")) {
                    throw new CmxBaseException(ResultCode.AUTH_TAKEN_OTP, "QR code is already taken");
                }
                return otpCol;
            }
        }
    }

    @Override
    public void killOtpCol(Otp otpCol) {
        otpCol.setIsValid("N");
        otpRepository.save(otpCol);
    }
}
```

아래 attribute 를 포함하는 테이블을 신규 생성하고 `@Entity` 를 추가 구현합니다.

- `resourceSeq`: 리소스 정보. OTP:리소스=N:1 관계를 가진다.
- `code`: OTP 코드
- `createTs`: 생성일 (epoch time)
- `expireTs`: 만료일 (epoch time)
- `isValid`: 유효 여부 ("Y"-사용 가능 / "N"-이미 사용됨)

```java
@Getter
@Setter
@Entity
@Table(name = "tbl_otp")
public class Otp {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(columnDefinition = "int")
    private Long seq;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "resourceSeq")
    private Resource resource;

    private String code;

    @Column(columnDefinition = "int")
    private Long createTs;

    @Column(columnDefinition = "int")
    private Long expireTs;

    @Column(columnDefinition = "char")
    private String isValid = "Y";
}
```

마지막으로 일종의 Garbage Collecting 과 같은 느낌으로 일정 주기에 따라 **만료 시간이 지났거나**, **이미 사용된** column 들은 삭제하도록 합니다.

```java
@Component
public class OtpScheduler {

    @Autowired
    private OtpRepository otpRepository;

    @Scheduled(fixedRateString = "${scheduler.fixedRate}")
    public void clearOtpCols() {
        long now = System.currentTimeMillis() - 3600_000;
        List<Otp> results = otpRepository.findByExpireAtLessThanOrIsValid(now, "N");
        otpRepository.deleteAll(results);
    }
}
```