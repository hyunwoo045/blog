---
title: "3rd-Party 연동 시스템 고도화"
excerpt: "연동 시스템 인프라 구조 개선 및 코드 경량화"

header:
overlay_image: https://images.unsplash.com/photo-1501785888041-af3ef285b470?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80
overlay_filter: 0.5

tags:
- Spring Boot
- Spring JPA (Hibernate, JPQL)

toc: true
toc_label: "table of content"
toc_icon: "bars"
toc_sticky: true
---

- 기간: 2023년 1월 ~ (현재 진행 중)
- 구성 인원: 2인
- 주요 업무
  - 기존 연동 시스템의 구조적 문제 개선 계획 수립 및 구현
  - 기존 데이터베이스 구조 경량화
  - 추가 연동 서비스 확장성 확보를 위한 코드 구조 개선
  - 개선된 구조 내 카카오홈 Extension 구현 (개인 업무)
- 23년 3월 기준 결과 없음 (프로젝트 진행 중)
- 기술 스택
  - Spring Boot
  - Spring JPA (Hibernate, JPQL)

2023년 3월 작성 기준 아직 뚜렷한 결과물이 없는 진행중인 프로젝트입니다. 
해당 기술서에서는 많은 논의를 통해 수립된 계획을 소개하도록 하겠습니다.

---

## 구조 개선 계획

기존 연동 시스템의 서버 인프라 구조는 특정 서버 인스턴스에 트래픽이 과집중되는 구조입니다.

![legacy](/images/openapi/1.png)

- `Adapter`: 말 그대로 어댑터의 역할을 합니다. 디바이스, 명령 포맷 등 각 연동사마다 다르게 표현하는 형식을 자사의 형태로 변환합니다.
- `OpenAPI`: 자사 클라우드 서비스와 직접 통신하여 "연동"에 대한 공통 기능 역할을 수행합니다.
- `Cloudv1, Cloudv2`: 자사 클라우드 서비스입니다.

차트에서 알 수 있다시피 `OpenAPI` 서버로의 트래픽이 집중되는 구조입니다. 기존에는 `OpenAPI` 서비스는 오로지 `Cloudv1` 서비스만을
대상으로한 서비스였으나 `Cloudv2` 서비스가 런칭되어 이를 포함하여 서비스한 시점(2021년 12월)에 문제가 발생하였습니다. 이는 당시
추가될 트래픽량을 예측하지 못한 점, Auto-scaling 기술이 적용되어 있지 않았던 점이 문제였으며 인스턴스를 증축하는 방식으로
해결하였었습니다. 

구조적인 문제가 핵심 원인인 것이 명확하고, 연동 서비스 추가 계획 됨에 따라 시스템 고도화 계획을 수립하게 됩니다. 

개선안은 아래와 같습니다. 세부적인 내용은 제외한 차트의 예시입니다.

![ext](/images/openapi/2.png)

세부 개요는 아래와 같습니다.

- 기존 `OpenAPI` 의 공통 기능을 `Adapter` 에 흡수시킨다.
- 전체 `Adapter` 는 하나의 바이너리를 가진다. (코드 통일화)
- 분리된 네트워크 환경(VPC)을 통일한다.

---

## 핵심 비즈니스 로직

가장 대표적인 기능인 디바이스 표현 형태를 변환하는 과정을 예시로 소개하겠습니다.

연동사 디바이스임을 명시할 추상 클래스를 생성합니다.

```java
public abstract class AbsPartnerDevice {
}
```

실제 특정 연동사 디바이스는 이 추상 클래스를 물려받은 후 특성을 구현해야 합니다. 객체 내부에 `convert` 라는 static 메서드를 구현하여 외부에서 사용할 수 있도록 구현합니다. 카카오 디바이스를 예로
드나 실제 코드와는 다른 예시입니다.

```java
import java.util.HashMap;

@Getter
@Setter
@JsonInclude(JsonInclude.Include.NON_NULL)
public class KakaoDevice extends AbsPartnerDevice {
    protected String id;
    protected String name;
    protected String displayType;
    protected String status;

    public KakaoDevice(CommaxDevice commaxDevice) {
        this.id = commaxDevice.getUuid();
        this.name = commaxDevice.getNickname();
    }

    public static KakaoDevice convert(CommaxDevice commaxDevice) {
        switch (commaxDevice.getType()) {
            case "switch":
                if ("light".equals(commaxDevice.getDeviceType()))
                    return new Light(commaxDevice);
                break;
            case "plug":
                // ...
                break;
            default:
                break;
        }
    }
}
```

```java
public class Light extends KakaoDevice {
    public Light(CommaxDevice commaxDevice) {
        super(commaxDevice);
        this.displayType = "Light";
        this.status = commaxDevice.getStatus();
    }
}
```

이와 같이 디바이스의 표현 형식을 정의하고 변환 메서드를 작성하면 아래와 같이 '전등'에 해당하는 코맥스 디바이스를 카카오 디바이스 표현 형태로 변경할 수 있겠습니다. 이러한 방식으로 연동사에서 지원하는 여러 디바이스들을 모두 구현한다면 '공통 기능'에서는 단순히
`convert` static 메서드를 호출하는 것으로 연동사의 디바이스 포맷을 생성할 수 있게 됩니다.

아래 코드는 코맥스 클라우드에서 디바이스 리스트를 받아와 연동사의 포맷으로 변환하여 반환해주는 함수의 코드 예시입니다.
이 또한 핵심 로직의 흐름을 표현한 것으로 일부 과정이 생략되어 있습니다.

```java
// 공통 기능

import java.util.ArrayList;

@Service
public class OpenApiService {

    @Autowired
    private CloudService service;

    public List<AdapterDevice> getDeviceListAndSync(Function<CommaxDevice, ? extends AbsPartnerDevice> converter) {
        List<CommaxDevice> deviceList = service.getDeviceListFromCloud();

        List<AbsPartnerDevice> filteredList = new ArrayList<>();
        for (CommaxDevice device : deviceList) {
            AbsPartnerDevice d = converter.apply(device);
            filteredList.add(d);
        }
        
        return filteredList;
    }
}
```