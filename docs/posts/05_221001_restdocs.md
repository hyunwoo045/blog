---
title: "Spring REST Docs 문서 자동화 시스템 도입"
excerpt: "제품 코드, 테스트 코드 작성만으로 API 문서를 자동으로 생성"

header:
overlay_image: https://images.unsplash.com/photo-1501785888041-af3ef285b470?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80
overlay_filter: 0.5

tags:

- Spring Boot
- JUnit
- MockMvc
- Spring REST Docs
- AsciiDocs
- Gitlab Pipeline
- AWS CloudFront

toc: true
toc_label: "table of content"
toc_icon: "bars"
toc_sticky: true
---

- 기간: 2022년 10월, 약 2주
- 구성 인원: 2인
- 주요 업무
    - Spring Boot Test 코드 작성
    - Spring REST Docs 적용
    - AsciiDocs 소스 파일 작성
    - Gitlab pipeline 코드 수정 (AWS S3 에 자동 생성된 HTML 문서 업로드)
    - AWS CloudFront 생성 및 S3 버킷 연결
- 결과: 기존 Google Docs API 문서 대체 완료.
- 개선점: 제품 코드와 테스트 코드를 작성하고 배포할 때에 API 문서가 자동 업데이트되어 별도의 조치 없이 실제 API 서비스와 문서가 동일함을 보장함.
- 기술 스택
    - Spring Boot (Java)
    - Spring Test (JUnit, SpringBootTest)
    - Spring REST Docs
    - AsciiDoc
    - Gitlab Pipeline
    - AWS CloudFront

자사 클라우드 서비스는 Google Docs 를 통해 타 개발자들에 API 문서를 공유하고 있었습니다.
하지만 인증/연동 서버 언어 변경 작업을 하던 중 실제 코드와 문서가 상이함을 알게 되었습니다.
클라이언트 앱 개발자들이 모두 해당 문서를 참고하고 개발을 진행하기 떄문에 꼼꼼하게 문서를 업데이트해야 하지만,
언제든 휴먼 에러는 발생하기 마련이기 때문에 이를 최소화하기 위해 자동화 시스템을 도입하기로 합니다.

## Swagger 를 선택하지 않은 이유

바로 REST Docs 를 도입하진 않았습니다. API 문서 자동 생성기는 아무래도 Swagger 가 워낙 유명하기 때문이었죠.

실제로 Swagger 를 도입했다가 얼마 안 있어 이를 드랍합니다. 사유는 **1. 실제 비즈니스 로직과 관계없는 어노테이션을 추가 작성해야 한다는 점**과
**2. 페이지 구성을 마음대로 커스텀할 수 없다는 점**, 마지막으로 **3. 문서가 실제 코드와 동기화되지 않을 수도 있다는 점** 입니다.

```java
public class UserController {
    @ApiOperation(value = "회원 삭제") // (1)
    @Transactional
    @DeleteMapping('/')
    public ResponseEntity<UserDto> userDelete(
        @ApiIgnore  // (2)
        @RequestHeader(value = "Authorization") String authorization,
        @ApiParam(value = "트랜젝션 구분자", required = true, defaultValue = "abcde") // (3)
        @ReqeustHeader(value = "Transaction-ID") String trxId
    ) {
        // do something to delete user
    }
}

// (1), (2), (3) 줄은 핵심 비즈니스 로직과는 전혀 관련이 없다.
// 또한 코드가 수정된다면 어노테이션도 직접 일일이 다 수정해야 한다. 이 과정에서 휴먼 에러 발생할 수 있다.
```

단점이 매우 명확하며 대체제가 있는 상황에서 이를 고집할 필요는 없어 보입니다.

## Spring REST Docs 도입

Spring REST Docs 는 상술한 Swagger 를 드랍한 사유 3가지를 커버칠 수 있는 훌륭한 스팩입니다.
테스트 코드를 기반으로 문서가 자동 생성되기 때문에 **실제 제품 코드와 분리된다는 점**,
`AsciiDoctor` 문법을 사용하여 **페이지 구성을 커스텀할 수 있으며**
테스트 코드에서 정의한 내용이 실제 코드와 다를 경우 테스트 단계에서 에러가 발생하기 때문에 빌드하기 전
**코드와 문서의 동기화 작업을 강요하여 휴먼 에러를 최소화** 한다는 강점이 있겠습니다.

Spring 에서 제공하는 [Spring REST Docs 공식 문서](https://docs.spring.io/spring-restdocs/docs/current/reference/htmlsingle/)를
바탕으로 프로젝트에 기술을 적용해 보도록 하겠습니다.

---

`spring-restdocs-asciidoctor`, `spring-restdocs-mockmvc` 의존성을 추가해줍니다. `spring-restdocs-asciidoctor` 는 `snippetsDir` 에
정의한 경로에 `.adoc` 파일을 자동으로 생성해주도록 설정해줍니다. `spring-restdocs-mockmvc` 는 `MockMvc` 를 확장하여 요청을 시뮬레이션하고 테스트 결과를 자동으로 문서화해줍니다.

```
plugins {
	id "org.asciidoctor.jvm.convert" version "3.3.2"
}

configurations {
	asciidoctorExt
}

dependencies {
	asciidoctorExt 'org.springframework.restdocs:spring-restdocs-asciidoctor:{project-version}' 
	testImplementation 'org.springframework.restdocs:spring-restdocs-mockmvc:{project-version}' 
}

ext { 
	snippetsDir = file('build/generated-snippets')
}

test { 
	outputs.dir snippetsDir
}

asciidoctor { 
	inputs.dir snippetsDir 
	configurations 'asciidoctorExt' 
	dependsOn test
}
```

`jar` 파일을 빌드하기 전에 문서를 먼저 생성하도록 설정합니다.

```
bootJar {
	dependsOn asciidoctor
	from ("${asciidoctor.outputDir}/html5") {
		into 'static/docs'
	}
}
```

테스트 코드에서 `MockMvc` 를 확장합니다. 기본 `MockModel` 객체를 생성하여 확장한 `MockMvc` 객체를 상속받아 사용할 수 있도록 구성하였습니다.

```java
public class BaseMockModel {
    protected MockMvc mockMvc;

    @BeforeEach
    public void setup(WebApplicationContext webApplicationContext, RestDocumentationContextProvider restDocumentation) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext)
            .apply(documentationConfiguration(restDocumentation))
            .build();
    }
}
```

테스트 코드를 작성합니다.

```java

@SpringBootTest
class ResourceControllerTest extends BaseMokcModel {

    public ResourceControllerTest() {
        super();
    }

    @Test
    void getResourceCenter() throws Exception {

        this.mockMvc.perform(RestDocumentationRequestBuilders.get("/resource/{resourceNo}/centerCode", ":resourceNo"))
            .andExpect(status().isOk())
            .andDo(document("resource-get-center-code",
                pathParameters(
                    parameterWithName("resourceNo").description("리소스 번호")
                ),
                responseFields(
                    fieldWithPath("resultCode").type(JsonFieldType.STRING).description("응답 코드"),
                    fieldWithPath("resultMessage").type(JsonFieldType.STRING).description("응답 메시지"),
                    fieldWithPath("centerCode").type(JsonFieldType.STRING).description("단지 코드")
                )
            ));
    }
}
```

빌드 후 `/build/generated-snippets/resource-get-center-code` 디렉토리가 생성되고 그 아래에 여러 `.adoc` 파일들이 생성됩니다.

자동 생성된 snippets 를 사용하기 위해서는 `.adoc` 소스 파일을 생성해야 합니다. 이 프로젝트는 Gradle 을 사용하므로 `src/docs/asciidoc/*.adoc`
경로에 생성합니다.

아래는 예시 코드입니다.

```
=== 단지 코드 조회
(캐나다 Smartone 요청 API). 리소스 번호로 단지 코드를 조회하는 API 입니다.

include::{snippets}/resource-get-center-code/http-request.adoc[]
include::{snippets}/resource-get-center-code/path-parameters.adoc[]
include::{snippets}/resource-get-center-code/response-fields.adoc[]
include::{snippets}/resource-get-center-code/response-body.adoc[]
```

이 후 빌드하면 `build/docs/asciidoc/*.html` 로 HTML 파일이 자동 생성됩니다.
아래와 같은 화면을 볼 수 있습니다. 자동 생성된 것 치고는 상당히 퀄리티가 좋아보입니다.

![gauth-v2-docs](/images/restdocs/1.png)

---

## 자동 배포

자동 생성된 HTML 파일이 자동 배포되도록 CI/CD 코드를 추가합니다.

```yml
# 생략....
build-job:
  stage: build
  script:
  #    ...
  artifacts:
    paths:
      - build/docs/asciidoc/sample.html

deploy-job:
  stage: deploy
  needs: [ "build-job" ]
  script:
    #   ...
    - aws s3 cp build/docs/asciidoc/sample.html s3://{path}/v2/api.html
```

---

## CloudFront 연결

API 문서는 외부에 공개되지 않는 내부 문서이고 용량이 매우 적은 HTML 파일을 제공하기 때문에 CloudFront 를 이용해야 할 필요성은 크지 않긴 하나, 
그래도 기왕 만든 거 50GB 이하의 리소스 제공은 무료이기도 하니 공부한다는 생각으로 S3 와 연결하였습니다.

---

이와 같은 방식으로 제품 코드와 테스트 코드를 작성하고 이를 배포(git push)하기만 하는 것으로 클라이언트에게 제공된 API 문서가 자동으로
업데이트되는 시스템을 구축할 수 있었습니다.