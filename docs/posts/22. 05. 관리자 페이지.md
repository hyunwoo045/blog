---
title: "관리자 페이지 - 버전 등록 페이지 개발"
date: "2022-12-17"
tag: ["Spring Boot", "Spring JPA", "Spring Web", "QueryDSL", "Vue.js"]
---

- 기간: 2022. 11 ~ 2022. 12, 약 2개월
- 주요 업무: 코맥스 클라우드 2.0 어드민 페이지 내 리소스 버전 등록 페이지 개발
- 업무 목적: 실제 유통된 리소스(월패드, 로비폰 등) 내 어플리케이션 버전 등록/업데이트를 위한 페이지 개발
- 개발 인원: 1인
- 프로젝트 스펙
    - Spring Boot
    - Spring Web MVC
    - Spring Security
    - QueryDSL
    - Vue.js

기존 코맥스 클라우드 2.0 의 관리자 페이지에 OTA(Over The Air) 기능을 추가하는 개발 건의
여러 요구사항 중 신규 버전 등록을 위한 페이지를 개발하는 업무를 담당하게 되었습니다.

---

## 프로젝트 구조 분석

기본적으로 Spring Web MVC 프레임워크를 사용한 프로젝트로 Apache Tiles 라이브러리를 사용하여
타일 기반의 레이아웃을 구현한 것으로 보입니다.

```java

@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    public void configureViewResolvers(ViewResolverRegistry registry) {
        TilesViewResolver viewResolver = new TilesViewResolver();
        registry.viewResolver(viewResolver);
    }

    @Bean
    public TilesConfigurer tilesConfigurer() {
        TilesConfigurer tilesConfigurer = new TilesConfigurer();
        tilesConfigurer.setDefinitions(new String[]{
            "/WEB-INF/layouts/**/*.tiles.xml",
            "/WEB-INF/views/**/*.tiles.xml"
        });
        tilesConfigurer.setCheckRefresh(true);
        return tilesConfigurer;
    }
}
```

여러 많은 타일들이 정의되어 있지만 가장 핵심으로 보이는 레이아웃 구성은 아래 코드입니다.

```html
<!--page.layout.jsp-->
<html lang="ko">
<head>
    <title></title>
    <!--....-->
</head>
<body>
<div class="page-container">
    <div class="page-content">
        <tiles:insertAttribute name="leftmenu"/>
        <div class="content-wrapper">
            <div class="content">
                <tiles:insertAttribute name="body"/>
                <tiles:insertAttribute name="footer"/>
            </div>
        </div>
    </div>
</div>
</body>
</html>
```

메인 페이지의 레이아웃을 정의한 모습입니다. 아주 간단해 보이는 HTML 구성이며, body attribute 에 구현한 레이아웃을 삽입할 수 있는 것으로 보입니다. 이 구성에
맞춰 `/WEB-INF/views/resource/resourcevermng` 라는 버전 관리 페이지의 디렉토리를 생성해주고 `views.tiles.xml` 파일을 생성하여 새로 만들 타일의 설정을 해주었습니다.

```html

<tiles-definitions>
    <definition name="resource/resourcevermng/*" extends="page.layout">
        <put-attribute name="body" value="/WEB-INF/views/resource/resourcevermng/{1}.jsp"/>
    </definition>
</tiles-definitions>
```

`resourcemng.jsp` 파일을 생성하여 실제 랜더링 될 페이지의 템플릿을 정의합니다. 페이지를 구성하는 프레임워크는 Vue.js 이므로 Vue.js 의 템플릿 문법에 대한 기억을 더듬어가며 코딩하였습니다.
세부 코드는 생략합니다.

```html

<div id="rootVM" v-cloak>
    <!--...-->
</div>

<script type="text/javascript" src="${contextPath}/app/resource/resourcevermng/resourcevermng.js"/>
```

최초 프로젝트를 구현한 분의 의도를 정확히 파악할 수는 없으나, 한 파일에 template 과 script 코드가 모두 다 들어가 가독성을 해치는 것을 방지하기 위함이 아니었을까 생각됩니다. `contextPath`
는 constant 전역 변수로써 `/src/resources/static` 입니다.

`src` attribute 에 정의된 파일을 생성하고 코드를 작성하였습니다. 세부 코드는 생략합니다.

```js
const rootVM = new Vue({
    name: 'RootVM',
    el: '#rootVM',
    created() {
    },
    data: {},
    computed: {},
    methods: {}
})
```

페이지 레이 아웃의 구성을 마쳤으니 이제 Resolver 가 `resource/resourcevermng/*` 이름의 타일을 불러올 수 있도록 컨트롤러 메서드를 구현합니다.

```java

@Controller
@RequestMapping("/resource/resourcevermng")
public class ResourceVersionManageController {

    @GetMappging("/")
    public String index(Model model) {
        // model.addAttribute()  필요한 데이터를 보내줍니다.
        return "/resource/resourcevermng/resourcevermng";
    }
}
```

---

### QueryDSL

요구되는 페이지 기능 상 쿼리가 필요하기 때문에 그에 관련 된 구조 또한 파악할 필요가 있었습니다. Spring 의 ORM 스펙 중 하나인 `QueryDSL`
을 사용하고 있습니다. 부분 필터링 기능을 구현해야 하는 어드민 페이지이었기 때문에 `QueryDSL` 채택은 아주 합리적이라고 생각합니다.

실제 구현한 코드를 예시로 들며 설명해보겠습니다.

![ota_resource_vermng](/images/ota/1.png)

화면에 보이듯 총 7개의 검색 필드가 존재하는데 7개의 필드를 모두 다 채워 검색해야 한다면 사용성이 매우 떨어지니 당연히 일부 필드만 채워 검색하더라도 필터가 적용된 검색 결과를 보여주어야 합니다. 이를 JPA 의
일반적인 쿼리 메서드로 구현한다고 하면 이 한 기능을 위해 수도 없이 많은 메서드를 정의해야 했을 것입니다.

```java
// 실제 코드가 아닌 예시입니다.

@Repository
public interface ResourceVersionRepository extends JpaRepository<ResourceVersion, Long> {
    List<ResourceVersion> findByModelName(String modelName);

    List<ResourceVersion> findByModelNameAndModelType(String modelName, String modelType);

    List<ResourceVersion> findByModelNameAndModelTypeAndVersion(String modelName, String modelType, String version);
    // .....수십개의 method T_T
}
```

이런 상황에서는 동적 쿼리가 작성 가능한 방법을 찾아야 하는데 `QueryDSL` 은 이를 해결해줄 JPQL 빌더입니다.

기존 설정이 이미 완료되어 있고 컴파일 시 `/target/generated-sources/java/{package}/entity` 아래 QModel 들이 생성되는 것을 확인하였으니 추가된 테이블을 정의합니다. 실제
코드와는 다른 예시입니다.

```java

@Entity
@Getter
@Setter
@Table(name = "tbl_resource_version")
public class ResourceVersion {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(columnDefinition = "int")
    private Long seqno;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "modelSeqno")
    private ResourceModel model;

    private String version;

    private String registerAdmin;

    private String updateAdmin;

    @Column(columnDefinition = "int")
    private Long registerTs;

    @Column(columnDefinition = "int")
    private Long updateTs;
}
```

이 후 다시 컴파일하면 `QResourceVersion` 이라는 새로운 QModel 이 생성된 것을 볼 수 있습니다.

```java

@Generated("com.querydsl.codegen.EntitySerializer")
public class QResourceVersion extends EntityPathBase<ResourceVersion> {
    //...
}
```

동적 쿼리를 작성합니다. 역시 실제 코드와 다른 예시입니다.

```java

@Repository
public class ResourceVersionRepository {

    @Autowired
    private JPAQueryFactory queryFactory;

    /**
     * SearchMap 은 ServletRequest 를 HashMap<String, Object> 의 형태로 변환시킨 객체입니다.
     */
    public QueryResults<Tuple> queryVersionList(SearchMap map, Sort sort) {
        BooleanBuilder filter = new BooleanBuilder();
        QResourceVersion v = new QResourceVersion("v");
        QResourceModel m = new QResourceModel("m");

        if (map != null) {
            String modelName = (String) map.get("modelName");
            String modelType = (String) map.get("modelType");
            String version = (String) map.get("version");

            // 동적 쿼리 조건문 추가 
            if (modelName != null) filter.and(m.modelName.eq(modelName));
            if (modelType != null) filter.and(m.modelType.eq(modelType));
            if (version != null) filter.and(v.version.eq(version));

            // 쿼리 실행
            JPAQuery<Tuple> query = queryFactory
                .select(m.modelName, m.modelType, v.version)
                .from(v)
                .leftJoin(v.model(), m)
                .where(filter);

            return query.fetResults();
        } else {
            // 필터 없이 전체 검색...
        }
    }
}
```

이 후 `QueryResults<Tuple>` 형태의 결과값은 DTO 형태로 변환하여 페이지에 전달하도록 구현하였습니다.

---

## AWS S3 에 바이너리 업로드

JavaScript 용 AWS SDK 가
있습니다. [공식 문서](https://docs.aws.amazon.com/ko_kr/sdk-for-javascript/v2/developer-guide/welcome.html) 를 참고하여 AWS S3 에 업로드가
가능하도록 구현하였습니다.

앞단은 엄밀히 따지자면 Node.js 프로젝트가 아니므로 브라우저 스크립트로 SDK 를 포함시켜야 했습니다.

```html
<!--resourcevermng.jsp-->

<!-- ..... -->
<script src="https://sdk.amazonaws.com/js/aws-sdk-2.1254.0.min.js></script>
```

AWS 접근 권한을 부여하기
위해 [공식 문서](https://docs.aws.amazon.com/ko_kr/sdk-for-javascript/v2/developer-guide/getting-started-browser.html) 의 1단계,
2단계 내용을 참고하여 CognitoIdentity Pool 을 생성하고 정책을 부여하였습니다. 이 후 권한을 가진 Pool ID 를 받을 수 있습니다. 이를 바탕으로 포함시킨 SDK 를 확장합니다.

마지막으로 역시 공식 문서를 참조하여 페이지에서 전달받은 바이너리 파일을 AWS S3에 업로드 하였습니다.

```js
async function uploadFileToS3() {
    // ...v-model > closure. file 에 관한 정보를 가져옴
    
    var credentials = new AWS.CognitoIdentityCredentials({
        IdentityPoolId: 'ap-northeast-2:key...'
    });
    AWS.config.update({
        region: 'ap-northeast-2',
        credentials,
    });
    let s3 = new AWS.s3({
        computeChecksums: true
    });
    let body = {
        Bucket: 'bucket-name',
        Body: file,
        Key: fileName
    }
    const putResult = await s3.putObject(body).promise();
}

```

