---
title: "코맥스 클라우드 2.0 인증/연동 서버"
date: "2023-04-14"
tag: ["Spring Boot", "Spring Data JPA", "Gitlab Pipeline", "Docker", "AWS ECS"]
---

- 기간: 2022-04 ~ 2022-08, 약 5개월
- 구성 인원: 1인
- 주요 업무
    - PHP to Java 기능 마이그레이션.
    - Spring Boot 프로젝트 구성
    - Dockerfile 작성 (빌드)
    - Gitlab pipeline 코드 작성 (CI/CD 배포)
    - AWS ECS Task 정의 및 서비스 생성 (클러스터 정의)
- 결과: 코드 이관 완료 및 22년 10월 상용 기존 서비스 대체 배포 완료.
- 개선점: MSA 내 타 구조와 동일한 언어 스펙으로 변경하여 유지 보수 측면에서 이점 확보.
- 기술 스택
    - Spring Boot (Java)
    - Spring JPA (Hibernate, JPQL)
    - Gitlab pipeline (CI/CD)
    - Docker
    - AWS ECS Cluster

---

# 프로젝트 소개

MSA 로 구성된 자사 백엔드 클라우드 서비스는 대부분의 서버 바이너리가 Java 로 작성되어 있음에도 불구하고 인증(Auth), 연동(Group) 서버는
PHP 코드로 작성되어 있었습니다. 이를 MSA 내 타 서버들과 동일한 언어 스펙으로 변경하는 것이 주 목적인 프로젝트입니다.

기존 코드가 존재하긴 하나 신규 프로젝트나 다름 없었습니다. 좋은 프로젝트를 구성하기 위하여 어떤 점을 고려하고 실제 코드로 구현하였는지
간단히 소개하도록 하겠습니다.

---

## 핵심 비즈니스 로직와의 코드 분리

컨트롤러 메서드에는 최대한 핵심 비즈니스 로직만을 남기고 나머지 코드들은 모두 분리하는 것은 선택이 아닌 필수입니다.
여기서 나머지 코드라 함은 가장 먼저 '로깅', '검증'과 같은 로직들이 생각이 납니다. 이러한 로직을 분리하여 별도 구현한다면
가독성 향상되어 유지 보수 용이성을 확보할 수 있고 이 후 협업을 함에 있어 타인에게 코드를 이해시키기 쉽다는 장점을 얻을 수 있겠습니다.

아래는 실제 기존 인증 서버 내 유저 아이디가 존재하는 지 검사하는 메서드의 PHP 코드를 일부 생략한 예시입니다.

```php
class UserController extends BaseController {

    public function userExistAction() {
  
        $this->view->disable();
        $response = new Response();
      
        $rawBody = $this->request->getJsonRawBody(true);
      
        $client = CmxCommon::checkClientOrThrow($rawBody);
      
        $userId = $rawBody['user']['userId'];
        if (StringUtil::isEmpty($userId)) throw new MissingMandatoryParameter("user.userId");
      
        $users = User::getUsersByUserId($userId);
      
        if(sizeof($users) > 0) {
            $response->setJsonContent(
                [
                    'resultCode' => ResultCode::NO_ERROR,
                    'resultMessage' => '',
                    'exist' => true
                ]
            );
            return $response;
        } else {
            $response->setJsonContent(
                [
                    'resultCode' => ResultCode::NO_ERROR,
                    'resultMessage' => '',
                    'exist' => false
                ]
            );
        }

        return $response;
    }
}
```

이미 충분히 반복이 될만한 동작들은 메서드로 빠져있는 상태이며, 매우 읽기 좋은 상태의 코드였습니다. 이 정도의 코드를 그대로 옮겨 쓰더라도
문제될 것 하나 없어 보입니다.

하지만 앞서 말씀드린대로 **핵심 비즈니스 로직**만을 남기고 나머지 **검증 로직**들은 컨트롤러 메서드 스코프 안에서
읽히지 않는 것이 좋겠습니다.

### AOP

처음 제시한 방안은 관점 지향 프로그래밍으로 코드를 분리하는 방법이었습니다.

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface CheckClient {}
```

커스텀 어노테이션을 생성하고,

```java
@Aspect
@Component
public class CheckClientAop extends BaseAop {
    @Pointcut("@annotation(....annotation.CheckClient)")
    private void enableCheckClient() {}
  
    @Before("enableCheckClient()")
    public void checkClient(JoinPoint joinPoint) {
        //... client 검증 로직
    }
}
```

`@CheckClient` 어노테이션이 달려 있는 핸들러가 실행되기 전에 Client 검증을 하도록 코드를 분리할 수 있었습니다.

```java
@Controller
@RequestMapping('/user')
public class UserController {
  
    @Autowired
    private UserService userService;
  
    @CheckClient
    @GetMapping('/exist')
    public boolean createUser(
        @RequestBody UserExistReq body
    ) {
        String userId = body.getUserId();
        User user = userService.getUserByUserId(userId);
        return user != null;
    }
}
```

하지만 위 검증 로직은 후술할 이유로 드랍되었습니다. 현재 Aspect 메서드는 로깅 및 exception 처리에 사용되고 있습니다.

아래는 로깅을 위해 Aspect 메서드를 사용한 예시입니다. 상세 코드는 생략합니다.

```java
@Aspect
@Component
public class GlobalAspect {
    @Order(0)
    @Around("within(controller..*)")
    public Object controllerAspectProcessor(ProceedingJoinPoint joinPoint) {
        HttpServletReqeust request = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest();
        StopWatch watch = new StopWatch();
        try {
            watch.start();
            joinPoint.proceed();
        } catch (Exception e) {
            // handle exception
        } finally {
            watch.stop();
            // log - request, watch.getTotalTimeMillis() 등...
        }
    }
}
```

### 검증 AOP 를 드랍한 이유

'검증'을 마친 후에는 요청자에 대한 정보를 얻을 수 있습니다. Request body 에 client 정보 (id, secret)을 명시했다면
client 에 대한 상세 정보를 데이터베이스에서 얻을 수 있고, Authorization 토큰을 가지고 들어왔다면 검증 과정에서 파싱하여
유저 정보를 얻을 수 있습니다. 이러한 정보는 실제 핵심 비즈니스 로직에 사용되는 경우가 드물지 않습니다.

하지만 Aspect 메서드를 통해 검증을 진행하였다면 클라이언트 혹은 유저 정보를 다시 컨트롤러 메서드로 넘겨주는 것이 쉽지 않습니다.
아래는 초기에 Aspect 메서드에서 컨트롤러 메서드로 데이터를 넘겨주기 위해 실제로 초기에 제가 구성했던 구조입니다.

```java
public class ThreadConst {
    public static ThreadLocal<Client> client = new ThreadLocal<>();
}
```

```java
@Aspect
@Component
public class CheckClientAop extends BaseAop {
  
    @Autowired
    private ClientService clientService;
  
    @Pointcut("@annotation(....annotation.CheckClient)")
    private void enableCheckClient() {}
  
    @Before("enableCheckClient()")
    public void checkClient(JoinPoint joinPoint) {
        Client client = clientService.checkClientValid();
        ThreadConst.client.set(client);
    }
}
```

```java
@Controller
@RequestMapping('/user')
public class UserController {
  
    @PostMapping('/')
    public void createUser() {
        System.out.println("새로운 유저를 생성할 거에요!");
      
        Client client = ThreadConst.client.get();
    }
}
```

`ThreadConst` 라는 스레드 로컬 값을 저장하기 위한 객체를 생성해서 분리 코드에서 스레드 로컬에 저장하고 실제 핸들러에서 꺼내쓰는
방식이었습니다. 동작에는 문제가 없는 코드이지만 메모리 관리를 철저히 해야 한다는 점, 의도한 작동을 보장할 수 없다는 점 등
전역 변수를 사용하였을 때의 문제점들을 이유로 지적받았습니다.

이를 구현하는 좋은 방법으로 **Resolver** 를 선택하였습니다.

### HandlerMethodArgumentResolver

컨트롤러 메서드 인자값들의 전처리를 위한 인터페이스로 여러 기능을 수행할 수 있지만 메서드에 특정 어노테이션을
붙혀서 원하는 데이터를 바인딩할 수 있다는 것을 활용하였습니다.

`Header: Authorization` 에 Bearer 토큰 값을 검증하고 필요한 데이터를 컨트롤러에게 넘겨주는
실제 코드를 간단히 요약한 것을 소개하겠습니다.

```java
// 바인딩 매개체로 사용할 어노테이션

@Target({ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface AuthToken {
    boolean required() default true;
}
```

```java
// Resolver 정의

@Component
@RequiredArgsConstructor
public class AuthTokenArgumentResolver implements HandlerMethodArgumentResolver {
  
    @Autowired
    private TokenParser parser;
  
    // 이 메서드에서 처리 가능한 파라미터인지를 판단
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.getParameterAnnotation(AuthToken.class) != null;
    }

    // supportsParameter 에서 AuthToken 어노테이션이 달린 인자를 확인하고 Header 의 토큰값을 파싱하여 해당 인자에 바인딩.
    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
        String authHeader = webRequest.getHeader("Authorization");
        if(authHeader != null) authHeader = authHeader.trim();
        return parser.parse(authHeader);
    }
}
```

```java
@Controller
@RequestMapping('/user')
public class UserController {
  
    @PostMapping('/')
    public void createUser(
        @AuthToken Object token  // 컨트롤러 메서드에서 파싱되어 활용 가능한 객체를 인자로 받아 사용
    ) {
        String name = token.getUserName();
    }
}
```

이러한 방식으로 '검증'에 필요한 코드들을 핵심 비즈니스 로직과 분리하였습니다.

---

## 데이터베이스

### JPA

요구 사항 특징 상 복잡하거나 동적인 쿼리를 구현할 필요가 없고 또한 데이터 자체가 객체로써 특정할만한 역할을 수행하지 않기 때문에
`mybatis` 등과 같은 ORM 개념이 없는 기술을 사용하더라도 문제될 것은 없었습니다만,
개발자의 **개발 편의성**과 이 역시 **핵심 비즈니스 로직**에 집중할 수 있는 환경을 구성하기 위해 JPA 를 사용합니다.

가장 무난한 `Hibernate` ORM 프레임워크를 채택하였으며 `JPQL` 로 쿼리를 구현합니다.

### Replication

Read-only 메서드가 압도적으로 많은 서비스 특성 상 실제 데이터베이스는 Master-Slave 구조로 분리되어 있고 Slave 데이터베이스가
Read 트랜잭션을 담당하고 있습니다. 이에 대해서 Replication 설정이 필요합니다.

```java
@Configuration
public class MasterDataSourceConfig {

    @Primary
    @Bean(name = "masterDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.master.hikari")
    public DataSource masterDataSource() {
        return DataSourceBuilder.create()
            .type(HikariDataSource.class)
            .build();
    }
}
```

```java
@Configuration
public class SlaveDataSourceConfig {

    @Bean(name = "slaveDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.slave.hikari")
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create()
            .type(HikariDataSource.class)
            .build();
    }
}
```

Master 설정과 Slave 설정을 나누어 객체를 생성해줍니다. Property 설정에 따라 다른 DataSource 가 생성됩니다.

DataSource 를 생성하였으니 라우팅 테이블과 같은 형태로 만들기 위한 설정을 해줍니다.

```java
// Transaction 성격에 따라 연결 유형을 결정할 수 있도록 설정
public class ReplicationRoutingDataSource extends AbstractRoutingDataSource {

    @Override
    protected Object determineCurrentLookupKey() {
        TransactionSynchronizationManager.isCurrentTransactionReadOnly() ? DataSourceType.Slave : DataSourceType.Master;
    }
}
```

```java
public class RoutingDataSourceConfig {
  
    // Map 생성
    @Bean(name = "routingDataSource")
    public DataSource routingDataSource(
        @Qualifier("masterDataSource") final DataSource masterDataSource,
        @Qualifier("slaveDataSource") final DataSource slaveDataSource
    ) {
        ReplicationRoutingDataSource routingDataSource = new ReplicationRoutingDataSource();
        Map<Object, Object> dataSourceMap = new HashMap<>();

        dataSourceMap.put(DataSourceType.Master, masterDataSource);
        if(useRdbSlave) dataSourceMap.put(DataSourceType.Slave, slaveDataSource);

        routingDataSource.setTargetDataSources(dataSourceMap);
        routingDataSource.setDefaultTargetDataSource(masterDataSource);

        return routingDataSource;
    }

    // 트랜젝션이 생성될 때가 아니라 실제 쿼리가 발생할 때에 connection 을 점유하도록 설정
    @Bean(name = "dataSource")
    public DataSource dataSource(@Qualifier("routingDataSource") DataSource routingDataSource) {
        return new LazyConnectionDataSourceProxy(routingDataSource);
    }

    // EntityManagerFactory 설정
    @Bean(name = "jpaEntityManagerFactory")
    public LocalContainerEntityManagerFactoryBean entityManagerFactory(@Qualifier("dataSource") DataSource dataSource) {
        Map<String, Object> prop = new HashMap<>();
        prop.put("hibernate.physical_naming_strategy", SpringPhysicalNamingStrategy.class.getName());
        prop.put("hibernate.implicit_naming_strategy", SpringImplicitNamingStrategy.class.getName());
        prop.put("hibernate.hbm2ddl.auto", env.getProperty("spring.jpa.hibernate.ddl-auto"));

        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
        em.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
        em.setDataSource(dataSource);
        em.setPackagesToScan("common.jpa.entity", "gauth.jpa.entity");
        em.setPersistenceUnitName("jpaEntityManager");
        em.setJpaPropertyMap(prop);

        return em;
    }

    // JpaTransactionManager 구현 및 bean 으로 등록
    @Bean(name = "jpaTransactionManager")
    public PlatformTransactionManager jpaTransactionManager(EntityManagerFactory entityManagerFactory) {
        JpaTransactionManager transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(entityManagerFactory);
        return transactionManager;
    }
}
```

설정을 마쳤으니 마지막으로 컨트롤러 메서드 별로 트랜젝션의 성격을 정해주어 올바른 데이터베이스 인스턴스로 라우팅되도록 해주었습니다.

```java
@Controller
@RequestMapping('/user')
public class UserController {
  
    @Transactional
    @PostMapping('/')
    public void createUser() {
        // ...
    }

    @Transactional(readOnly = true)
    @GetMapping('/')
    public void getUserInfo() {
        // ...
    }
}
```

## Exception

예측 가능한 범위의 exception 들은 커스텀한 `RuntimeException` 을 던져 AOP 에서 알맞는 Response body 생성하여
응답하도록 구성하였습니다.

```java
public class BaseException extends RuntimeException {
    public String code = "9999";
    public String message = "";
  
    public BaseException(String code, String message) {
        super(message);
        this.code = code;
        this.message = message;
    }
}
```

```java
@Controller
@RequestMapping('/user')
public class UserController {

    @GetMapping('/')
    public void getUserInfo(
        @RequestBody UserReq body
    ) {
        // ...
        User user = userService.getUserById(body.getUserId());
        if (user == null) throw new BaseException(400, "User ID is not found");
    }
}
```

```java
public class GlobalExceptionHandler {
    public static ResponseEntity<BaseResponse> handle(Exception e) {
        if (e instanceof BaseException) {
            code = ((BaseException) e).code;
            message = ((BaseException) e).message;
        }
        return BaseResponse.toResponseEntity(code, message);
    }
}
```

```java
@Aspect
@Component
public class GlobalAspect {
  
    @Order(0)
    @Around("within(controller..*)")
    public Object controllerAspect(ProceedingJoinPoint joinPoint) {
        Object returnObject = null;
        try {
            returnObject = joinPoint.proceed();
        } catch (Exception e) {
            returnObject = GlobalExceptionHandler.handle(e);
        }
      
        return returnObject;
    }
}
```

Exception 이 발생하더라도 원하는 형태의 응답이 내려가도록 처리할 수 있습니다.

또한 프레임워크에서 발생시키는 exception 들의 경우도 커스텀한 exception 으로 처리할 필요가 있었기 때문에 `@ControllerAdvice` 객체를 통해 처리하도록 추가 작업하였습니다.

```java
@ControllerAdvice
public class GlobalExceptionHandler {
    public static ResponseEntity<BaseResponse> handle(Exception e) {
        if (e instanceof BaseException) {
            code = ((BaseException) e).code;
            message = ((BaseException) e).message;
        }
        return BaseResponse.toResponseEntity(code, message);
    }
  
    /** 
     * RequestBody 어노테이션이 있는 컨트롤러 메서드임에도 불구하고 JSON body 가 없는 경우
     */
    @ExceptionHandler(HttpMessageNotReadableException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ResponseBody
    public ResponseEntity<BaseResponseDto> handle(HttpServletRequest req, HttpMessageNotReadableException e) {
        return GlobalExceptionHandler.handle(new ParamVerifyException("Something is wrong with request body: " + e.getMessage()));
    }

    /**
     * RequestHeader 어노테이션으로 명시된 필수 입력 헤더가 비어 있는 경우
     */
    @ExceptionHandler(MissingRequestHeaderException.class)
    @ResponseStatus(HttpStatus.OK)
    @ResponseBody
    public ResponseEntity<BaseResponseDto> handle(HttpServletRequest req, MissingRequestHeaderException e) {
        return GlobalExceptionHandler.handle(new MissingMandatoryHeaderException(e.getMessage()));
    }

    /**
     * RequestParam 어노테이션으로 명시된 필수 입력 파라미터가 누락된 경우
     */
    @ExceptionHandler(MissingServletRequestParameterException.class)
    @ResponseStatus(HttpStatus.OK)
    @ResponseBody
    public ResponseEntity<BaseResponseDto> handle(HttpServletRequest req, MissingServletRequestParameterException e) {
        return GlobalExceptionHandler.handle(req, new ParamVerifyException(e.getMessage()));
    }
}
```

위와 같은 방식으로 발생 가능한 Exception 을 최대한 고려하여 클라이언트에게 식별 가능한 응답이 내려가도록 구현하였습니다.

## 빌드와 배포

Docker 컨테이너를 통해 서비스를 구동하는 기존 다른 서버와 동일하게 배포 방식을 가져가야 했습니다. 그러기 위해서는
아래와 같은 점들을 고려해야 했습니다.

1. AWS ECS cluster 에 서비스가 등록될 예정이기 때문에 SSH 접속을 위한 조치가 필요
2. ELK 구조를 통해 로그를 AWS OpenSearch 서비스에 적재하므로 filebeat 설정이 필요
3. develop, stage, production 으로 3가지 환경이 나누어지므로 추가 설정이 필요

도커파일 구성은 아래와 같습니다. 실제 코드를 생략하고 동작 순서를 간단히 설명합니다.

```dockerfile
# alpine 리눅스를 사용합니다.
FROM alpine:3.15  
# openjdk11-jre logrotate openssh filebeat 설치
# project 내 key file 을 ADD 하고 권한 부여
# JAVA_HOME 환경 변수 등록
# project 내 바이너리 실행 script를 ADD (entrypoint.sh)
# project 내 filebeat 설정 파일을 ADD 하고 필요한 권한을 부여
# build 되어 있는 jar 파일을 ADD
ENTRYPOINT /root/entrypoint.sh
```

배포는 git commit push 시 pipeline 이 동작하도록 구성되어 있습니다. 팀 내 형상 관리는 gitlab 을 사용하고 있으며
gitlab 의 CI/CD 는 pipeline 으로 구현됩니다. 아래는 실제 pipeline 코드에서 핵심 코드만 간추린 예시입니다.

```yml
stages:
  - versioning
  - build
  - deploy

versioning-job:
  stage: versioning
  script:
    - CURR_VER=$(cat build.gradle | grep "version =" | sed -E 's/version = "(.*)"$/\1/')

build-job:
  stage: build
  script:
    - ./gradlew build
    - docker build . -t cloud-v2-gauth

deploy-job:
  stage: deploy
  needs: [ "versioning-job", "build-job" ]
  script:
    #   aws-cli ECR login | AWS docker login
    - TAG="$CI_COMMIT_BRANCH"
    - >
      if [ "$CI_COMMIT_BRANCH" = "master" ]; then
        TAG="latest"
      fi
  #   이미지를 AWS ECR 에 푸시
  dependencies:
    - build-job
```

이와 같이 구성하여 코드 푸시가 일어난다면 AWS ECR 에 이미지가 업데이트가 되고, 업데이트가 완료되면
인스턴스 내에서 컨테이너 재시작 (개발 환경), 클러스터 서비스의 Task 에 새 배포를 적용하여 재시작(스테이지, 상용 환경)하는 것으로
신규 버전의 어플리케이션을 배포합니다.
